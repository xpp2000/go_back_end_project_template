package router

import (
	stdContext "context"
	"fmt"
	"gogofly/global"
	"os"
	"os/signal"
	"syscall"
	"time"

	_ "gogofly/docs"

	"github.com/iris-contrib/swagger/v12"
	"github.com/iris-contrib/swagger/v12/swaggerFiles"
	"github.com/kataras/iris/v12"
	"github.com/kataras/iris/v12/core/router"
	"github.com/spf13/viper"
	// docs folder should be generated by Swag CLI (swag init),
	// you have to import it.
)

type IFnRegisterRoute = func(rgPublic router.Party, rgAuth router.Party)

var (
	gfnRoutes []IFnRegisterRoute
)

func RegisterRoute(fn IFnRegisterRoute) {
	if fn == nil {
		return
	}
	gfnRoutes = append(gfnRoutes, fn)
}

func InitRouter() {

	app := iris.New()
	app.Logger().SetLevel("debug")

	rgPublic := app.Party("/api/v1/public")
	rgAuth := app.Party("/api/v1/auth")

	InitBasePlatformRoutes()
	// = register module routers
	for _, fnRegisterRoute := range gfnRoutes {
		fnRegisterRoute(rgPublic, rgAuth)
	}

	// = integrate swagger
	config := &swagger.Config{
		URL: "http://localhost:8888/swagger/doc.json", //The url pointing to API definition
	}
	// use swagger middleware to
	app.Get("/swagger/{any:path}", swagger.CustomWrapHandler(config, swaggerFiles.Handler))

	// = reading server settings from viper
	stPort := viper.GetString("server.port")
	if stPort == "" {
		stPort = "8888"
	}

	// gracefully exit
	idleConnsClosed := make(chan struct{})
	go func() {
		ch := make(chan os.Signal, 1)
		signal.Notify(ch,
			// kill -SIGINT XXXX or Ctrl+c
			os.Interrupt,
			syscall.SIGINT, // register that too, it should be ok
			// os.Kill  is equivalent with the syscall.Kill
			os.Kill,
			syscall.SIGKILL, // register that too, it should be ok
			// kill -SIGTERM XXXX
			syscall.SIGTERM,
		)
		select {
		case <-ch:
			println("shutdown...")

			timeout := 10 * time.Second
			ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
			defer cancel()
			app.Shutdown(ctx)
			close(idleConnsClosed)
		}
	}()

	// Start the server and disable the default interrupt handler in order to
	// handle it clear and simple by our own, without any issues.
	err := app.Run(
		iris.Addr("localhost:8888"),
		iris.WithoutServerError(iris.ErrServerClosed),
		iris.WithOptimizations,
		iris.WithoutInterruptHandler,
	)
	if err != nil {
		// Logger
		global.Logger.Error(fmt.Sprintf("Start Server Error: %s", err.Error()))
		// panic(fmt.Sprintf("Start Server Error: %s", err.Error()))
	}
	global.Logger.Info("Start Listen successfully")

	<-idleConnsClosed
	global.Logger.Info("Stop Server successfully")
	// fmt.Println("Stop Server successfully")
}

func InitBasePlatformRoutes() {

	InitUserRoutes()
}
